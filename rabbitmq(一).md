# 集群和高可用

集群的作用：

- 高可用：当主节点挂了后可以用其他节点代替
- 负载均衡：高并发场景中，单台MQ处理消息能力有限，可以分发到其他节点进行消息处理



## rabbitmq中的集群

rabbitmq时基于erlang开发的，而erlang天生具有分布式特性，所以rabbitma天生支持集群。

集群模式：

- 普通集群模式
- 镜像队列模式

节点类型：

- 磁盘节点：元数据（队列名字属性、交换机的类型名字属性、绑定、vhots）保存在了磁盘
- 内存节点：元数据保存在了内存（其将磁盘的地址放在了磁盘，不然重启后没法同步数据）

注：如果是持久化的消息，会同时放进磁盘和内容

集群中必须有一个节点为磁盘节点用来持久化数据，否则全部内存节点崩溃时数据会丢失。一般情况下应用连接内存节点，磁盘节点用来备份。



集群配置步骤：

1. 配置hosts
2. 同步erlang.cookie
3. 加入集群



### 普通集群

​	普通集群模式下，不同节点之间只会相互同步元数据

![1569225951794](D:\BaiduNetdiskDownload\markdown笔记\rabbitmq(一).assets\1569225951794.png)

在其中，队列的内容是不会相互同步的

优点：

- 减少了队列数据同步的网络开销
- 达到了线性增加性能和存储容量的目的

缺点：

- 不能保证高可用，如果节点失效将导致队列数据丢失

节点调用过程：

- 假如生产者连接的是节点 3，要将消息通过交换机 A 路由到队列 1，最终消息还是会
  转发到节点 1 上存储，因为队列 1 的内容只在节点 1 上。
- 同理，如果消费者连接是节点 2，要从队列 1 上拉取消息，消息会从节点 1 转发到
  节点 2。其它节点起到一个路由的作用，类似于指针。 



### 镜像队列

镜像队列中，队列中数据也就是消息会互相同步。

优点：

- 可用性更高

缺点：

- 系统性能降低，节点过多情况下同步代价大

| 操作方式              | 命令或步骤                                                   |
| --------------------- | ------------------------------------------------------------ |
| rabbitmqctl (Windows) | rabbitmqctl set_policy ha-all "^ha." "{""ha-mode"":""all""}" |
| HTTP API              | PUT /api/policies/%2f/ha-all {"pattern":"^ha.", "definition":{"ha-mode":"all"}} |
| Web UI                | 1、 avigate to Admin > Policies > Add / update a policy 2、 Name 输入： mirror_image 3、 Pattern 输入： ^（代表匹配所有） 4、 Definition 点击 HA mode， 右边输入： all 5、 Add policy |



高可用的集群架构：

![1569227299207](D:\BaiduNetdiskDownload\markdown笔记\rabbitmq(一).assets\1569227299207.png)

规划：

- 内存节点1：192.168.8.40 
- 内存节点2：192.168.8.45 
- 磁盘节点：192.168.8.150 
- VIP：192.168.8.220 



# 常见面试题

1. 消息队列的作用与使用场景

   （队列作用：存取消息）

   消息通讯、消息中间件，平台无关的独立服务。

   异步通信、系统解耦、流量削峰、日志处理、消息通讯

2. channel和vhost作用

   channel可认为是一个虚拟连接，可以使得不用重复创建connection，减少tcp的消耗，同时也是最重要的编程接口。

   vhost是虚拟域名，不同vhost中的exchange和queue都是隔离的。它提高了硬件资源利用率，实现资源隔离

3. rabbitmq有哪些路由方式？适合场景分别是什么

   - derect
   - topic
   - fanout

4. 交换机与队列、队列与消费者的绑定关系是什么样的？
   多个消费者监听一个队列时（比如一个服务部署多个实例），消息会重复消
   费吗？
   多对多；
   轮询（平均分发） 

5. 无法被路由的消息，去了哪里？
   直接丢弃。可用备份交换机（alternate-exchange）接收 

6. 消息在什么时候会变成 Dead Letter（死信）？ 

   - 消息过期
   - 队列长度、容量达到最大
   - 被消费者拒绝并未设置重新入队

7. 如果一个项目要从多个服务器接收消息，怎么做？如果一个项目要发送消息到多个服务器，怎么做？ 

   - 定义多个connectionFactory，注入到消费者监听类/Temaplate 

8. rabbitmq怎么实现延时队列

   - 数据库+定时任务
   - 死信队列
   - 延迟队列插件

9. 哪些情况会导致消息丢失？怎么解决？哪些情况会导致消息重复？怎么解决？

   - 消息丢失
     - 生产者发送了，broker实际没收到
       - 解决：事务模式、confirm模式（单个、批量、异步）
     - 交换机没路由到队列
       - 解决：生产者重发、备份交换机
     - 队列中消息丢失
       - 解决：交换机、队列、消息持久化；集群
     - 消息没成功被消费者消费
       - 解决：消费端确认机制：自动ack、手动ack
   - 消息重复
     - 生产者重发：解决方式：消费端的消息幂等

10. 一个队列最多存储多少条消息？

    - 由设置的队列参数（长度、容量）、硬件资源决定

11. 可以用队列的 x-max-length 最大消息数来实现限流吗？例如秒杀场景 。

    - 不能，会删除先入队的消息。

12. 如果提高消费速率？

    - 增加消费者

13. AmqpTemplate 和 RabbitTemplate 的区别？ 

    - Spring AMQP 是 Spring 整合 AMQP 的一个抽象。Spring-Rabbit 是一个实
      现。 就像AMQP是一个标准，rabbitmq是实现

14. 如何动态地创建消费者监听队列？ 

    - 通过 ListenerContainer

      ```java
      com.gupaoedu.amqp.container.ContainerConfig.java
      container.setQueues(getSecondQueue(), getThirdQueue()); //监听的队列 
      ```

15. Spring AMQP 中消息怎么封装？用什么转换？ 

    - Message、MessageConvertor

16. 如何保证消息的顺序性？

    - 一个队列单一消费者

17. rabbitmq集群节点类型？

    - 磁盘节点
    - 内存节点

18. rabbitmq集群类型？

    - 普通集群（只同步元数据，不同步队列消息）
    - 镜像队列

19. 如何保证rabbitmq的高可用？

    - HAProxy（LVS）+keepalive

20. 大量消息堆积怎么办？

    - 重启
    - 多创建几个消费者消费
    - 清空队列，重发消息

21. MQ选型分析

    - 使用和管理
      - API、与 Spring 集成
      - 管理控制台，权限、安全、监控
      - 扩展性
      - 社区支持
    - 性能
      - 并发性
      - 消息吞吐量
      - 消息堆积能力 
    - 功能
      - 事务性消息
      - 顺序性消息
      - 消息重试
      - 死信队列
      - 优先级队列
      - 延迟队列 
    - 可靠+可用
      - 集群
      - 持久化
      - 消息同步 

22. 设计MQ，你的思路是什么？

    - 存储与转发。
    - 存储：内存：用什么数据结构？
    - 磁盘：文件系统？数据库？
    - 通信：通信协议（TCP HTTP AMQP ）？一对一？一对多？
    - 推模式？拉模式？ 

